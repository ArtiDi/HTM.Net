using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace HTM.Net.Util
{
    /**
     * <p>
     * Allegory to the Python itertools.groupby. Objects of this class
     * take a list of inputs and a function to produce keys. The iterator
     * or foreach loop generates grouped return values based on the key
     * generated by the supplied function.<br>
     * For instance:<br>
     * <pre>
     * Given the list:
     * List<Integer> l = Arrays.asList(new Integer[] { 2, 4, 4, 5 });
     * and the function:
     * Function<Integer, Integer> lambda = x -> x * 3;
     * 
     * A GroupBy can be compose as such:
     * GroupBy<Integer, Integer> grouper = GroupBy.of(l, lambda);
     * 
     * ...then iterated over as such:
     * for(Pair<Integer, Integer> p : grouper) {
     *     System.out.println("Pair key: " + p.getKey() + ", pair value: " + p.getValue());
     * }
     * 
     * Outputs:
     * 
     * Pair key: 2, pair value: 6
     * Pair key: 4, pair value: 12
     * Pair key: 4, pair value: 12
     * Pair key: 5, pair value: 15
     * </p>
     * <p>
     * Notes: Read up on groupby here:
     *        https://docs.python.org/dev/library/itertools.html#itertools.groupby
     *        
     * @param <T>
     * @param <R>
     */
    public class GroupBy<T, R> : Generator<Tuple<T, R>> //, PeekableIterator<Pair<T, R>> 
    {

        /** serial version */
        private const long serialVersionUID = 1L;

        private List<T> iter;
        private Func<T, R> fn;
        private IntGenerator range;
        private Tuple<T, R> next;


        /**
         * Constructs a new {@code GroupBy}
         * 
         * @param l     the {@link List} containing the items used as input to the
         *              key generating function.     
         * @param fn    the {@link Function} to be used to generate the keys which describe
         *              the like contents of each grouping.
         */
        public GroupBy(List<T> l, Func<T, R> fn)
        {
            this.iter = l;
            this.fn = fn;
            this.range = IntGenerator.Of(0, iter.Count);

            if (range.MoveNext())
            {
                T t = iter[range.Current];
                //next = new Pair<T, R>(t, fn.apply(t));
                //T t = (T) Convert.ChangeType(range.Current, typeof(T));
                next = new Tuple<T,R>(t, fn(t));
            }
        }

        /**
         * {@inheritDoc}
         */
        public Tuple<T, R> Peek()
        {
            return Current;// next;
        }

        #region Overrides of Generator<Tuple<T,R>>

        public override bool MoveNext()
        {
            if (next != null)
            {
                object t = range.MoveNext() ? (object) iter[range.Current] : null;
                Tuple<T, R> ret = next;
                next = t != null ? new Tuple<T, R>((T)t, fn((T)t)) : null;
                Current = ret;
                return true;
            }
            return false;
        }

        #endregion

        /**
         * Returns a new {@code GroupBy} composed from the specified list 
         * and key-generating {@link Function}
         * 
         * @param l     the {@link List} containing the items used as input to the
         *              key generating function.     
         * @param fn    the {@link Function} to be used to generate the keys which describe
         *              the like contents of each grouping.
         * @return
         */
        public static GroupBy<T, R> Of(List<T> l, Func<T, R> fn)
        {
            return new GroupBy<T, R>(l, fn);
        }

        public static GroupBy<T, R> Of(ICollection l, Func<T, R> fn)
        {
            return new GroupBy<T, R>(l.Cast<T>().ToList(), fn);
        }
    }
}